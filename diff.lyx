#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Utilidades Diff y Patch
\end_layout

\begin_layout Author
Maximiliano Ezequiel Matos y Lucas Moauro
\end_layout

\begin_layout Date
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Date
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introducción
\end_layout

\begin_layout Standard
Este informe contiene la documentación del trabajo práctico especial realizado
 para la cátedra de Análisis y Diseño de Algoritmos I.
\end_layout

\begin_layout Standard
La primera etapa del trabajo consiste en el diseño y la implementación de
 una utilidad denominada 
\emph on
diff
\emph default
, que dados dos archivos (origen y objetivo) devuelva una secuencia de cambios
 que permiten pasar de uno a otro.
\end_layout

\begin_layout Standard
Para el diseño del proyecto se tuvieron en cuenta tanto los tipos de datos
 necesarios, como el algoritmo a implementar.
\end_layout

\begin_layout Standard
En cuanto a los tipos de datos, se consideraron los cuatro principales:
 Línea, Archivo, Cambio y Diferencial y otros auxiliares: Lista, IteradorLista,
 Subsecuencia, ParInt y Arreglo, que fueron necesarios para poder implementar
 el algoritmo.
 Además se realizaron las correspondientes especificaciones en NEREUS de
 los TDAs.
\end_layout

\begin_layout Standard
El algoritmo empleado para buscar una subsecuencia común entre los archivos
 fue seleccionado de acuerdo a los requerimientos del enunciado, por lo
 que no se eligió el óptimo.
 Se realizó un análisis de la complejidad temporal de dicho algoritmo, así
 como también del utilizado para crear la lista de cambios.
\end_layout

\begin_layout Standard
Para la implementación, se utilizó el lenguaje C++ y el entorno de desarrollo
 integrado (IDE) 
\emph on
Code::Blocks
\emph default
.
 Se procedió llevando las especificaciones algebraicas de los TDAs a clases
 de C++ e implementando el mencionado algoritmo.
\end_layout

\begin_layout Section
Tipos de datos abstractos
\end_layout

\begin_layout Subsection
Tipos auxiliares
\end_layout

\begin_layout Standard
Además de los tipos principales necesarios se implementaron tipos auxiliares,
 que permiten lograr una especificación mas general en términos de los TDAs
 ya conocidos.
\end_layout

\begin_layout Standard
El soporte de herencia del lenguaje NEREUS nos permitió definir algunos
 de los los tipos principales a partir de los auxiliares, y a su vez, existen
 relaciones de herencia entre tipos auxiliares.
\end_layout

\begin_layout Subsubsection
Lista
\end_layout

\begin_layout Standard
Es una lista genérica, pero con funcionalidad reducida comparado con la
 especificación estándar de lista.
 Este tipo sólo permite inserciones al final y al principio.
 No es posible eliminar elementos.
\end_layout

\begin_layout LyX-Code
CLASS Lista[Elem]
\end_layout

\begin_layout LyX-Code
IMPORTS Boolean
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS crear, agregarFinalLista
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES Lista
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $crear:\:\rightarrow Lista$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $agregarFinalLista:\: Lista\: x\: Elem\rightarrow Lista$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $agregarPrincipioLista:\: Lista\: x\: Elem\rightarrow Lista$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $vaciaLista:\: Lista\rightarrow Boolean$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
IteradorLista
\end_layout

\begin_layout Standard
Este tipo tiene el objeto de permitir acceder a los elementos de una lista
 secuencialmente.
\end_layout

\begin_layout LyX-Code
CLASS IteradorLista[Elem]
\end_layout

\begin_layout LyX-Code
IMPORTS Boolean, Lista[Elem]
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS crear
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES IteradorLista
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $crear:\: Lista\rightarrow IteradorLista$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $terminado:\: IteradorLista\rightarrow Boolean$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $sucesor:\: IteradorLista\left(i\right)\rightarrow IteradorLista$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:\: not\: terminado\left(i\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Formula $elemActual:\: IteradorLista\left(i\right)\rightarrow Elem$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:\: not\: terminado\left(i\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
ParInt
\end_layout

\begin_layout Standard
Es un tipo contenedor de dos números enteros.
 Se utiliza para definir el tipo subsecuencia.
\end_layout

\begin_layout LyX-Code
CLASS ParInt
\end_layout

\begin_layout LyX-Code
IMPORTS Int
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS crear
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES ParInt
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $crear:\: Int\: x\: Int\rightarrow ParInt$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getPrimero:\: ParInt\rightarrow Int$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getSegundo:\: ParInt\rightarrow Int$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
Subsecuencia
\end_layout

\begin_layout Standard
Es una lista de pares de números enteros.
 Su función en el sistema es la de contener los índices de las líneas de
 una subsecuencia común entre dos archivos.
\end_layout

\begin_layout LyX-Code
CLASS Subsecuencia
\end_layout

\begin_layout LyX-Code
IMPORTS ParInt
\end_layout

\begin_layout LyX-Code
INHERITS Lista[ParInt]
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES Subsecuencia
\end_layout

\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsection
Tipos Principales
\end_layout

\begin_layout Subsubsection
Línea
\end_layout

\begin_layout Standard
Representa una cadena de caracteres.
 La funcionalidad básica es la de modificar y devolver un carácter de una
 posición(setChar y getChar).
 También se agregó a la especificación la función para comparar dos líneas
 por igualdad(iguales).
\end_layout

\begin_layout LyX-Code
CLASS Línea
\end_layout

\begin_layout LyX-Code
IMPORTS Char, Boolean, Nat
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS Crear, setChar
\end_layout

\begin_layout LyX-Code
TYPES Línea
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $Crear:\: Nat\rightarrow Línea$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $tamaño:\: Línea\rightarrow Nat$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getChar:\: Línea\left(l\right)\: x\: Nat\left(n\right)\rightarrow Char$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:1\leq n\leq tamaño(l)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Formula $setChar:\: Línea(l)\: x\: Nat(n)\: x\: Char\rightarrow Línea$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:1\leq n\leq tamaño(l)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Formula $iguales:\: Línea\: x\: Línea\rightarrow Boolean$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
Archivo
\end_layout

\begin_layout Standard
Es la representación de una secuencia de líneas.
 Su funcionalidad es dar acceso aleatorio a las líneas(getLinea y setLinea).
 
\end_layout

\begin_layout LyX-Code
CLASS Archivo
\end_layout

\begin_layout LyX-Code
IMPORTS Línea, Nat
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS Crear, setLinea
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES Archivo
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $Crear:\: Nat\rightarrow Archivo$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getCantLíneas:\: Archivo\rightarrow Nat$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getLínea:\: Archivo\left(a\right)\: x\: Nat\left(n\right)\rightarrow Línea$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:\:1\leq n\leq getCantLíneas\left(a\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
\begin_inset Formula $setLínea:\: Archivo\left(a\right)\: x\: Nat\left(n\right)\: Línea\rightarrow Archivo$
\end_inset


\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $pre:\:1\leq n\leq getCantLíneas\left(a\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
Cambio
\end_layout

\begin_layout Standard
Representa un cambio genérico a un archivo, sirve de base para los dos tipos
 de cambio específicos.
 Su funcionalidad es la de producir y aplicar eliminaciones o adiciones
 a un archivo en la porción que le corresponde.
 La función getDiff retorna en el formato diff las modificaciones que deben
 realizarse.
 AplicarPatch retorna un archivo modificado con el cambio aplicado.
 GetCantLineas retorna la cantidad de líneas que edita el cambio.
\end_layout

\begin_layout LyX-Code
CLASS Cambio
\end_layout

\begin_layout LyX-Code
IMPORTS Nat, Archivo, Boolean
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS crear
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES Cambio
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $crear:\: Nat\: x\: Nat\: x\: Nat\: x\: Archivo\rightarrow Cambio$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getDiff:\: Cambio\rightarrow Archivo$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $aplicarPatch:\: Cambio\: x\: Archivo\rightarrow Archivo$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getCantLíneas:\: Cambio\rightarrow Nat$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
CambioAgregar
\end_layout

\begin_layout Standard
Es un tipo heredado de cambio que define la operación para agregar un conjunto
 de líneas.
\end_layout

\begin_layout LyX-Code
CLASS CambioAgregar
\end_layout

\begin_layout LyX-Code
INHERITS Cambio
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES CambioAgregar
\end_layout

\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
CambioEliminar
\end_layout

\begin_layout Standard
Es el tipo correspondiente a la operación para eliminar un conjunto de líneas.
\end_layout

\begin_layout LyX-Code
CLASS CambioEliminar
\end_layout

\begin_layout LyX-Code
INHERITS Cambio
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES CambioEliminar
\end_layout

\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Subsubsection
Diferencial
\end_layout

\begin_layout Standard
Es el tipo más importante del sistema.
 Es una lista de cambios pero con funcionalidad extendida.
\end_layout

\begin_layout Standard
Las dos formas de instanciar la clase Diferencial son:
\end_layout

\begin_layout Itemize
A partir de dos Archivos(origen y objetivo) y una subsecuencia común.
\end_layout

\begin_layout Itemize
A partir de dos Archivos(origen y diff) y un bool(para especificar si se
 debe invertir el diff).
\end_layout

\begin_layout Standard
La función getDiff retorna un archivo en el formato del diff con la concatenació
n de los diffs de sus cambios.
 La función aplicarPatch retorna un archivo resultante de realizar las modificac
iones de cada uno de sus cambios al archivo pasado en el constructor.
\end_layout

\begin_layout LyX-Code
CLASS Diferencial
\end_layout

\begin_layout LyX-Code
IMPORTS Subsecuencia, Archivo, Lista[Cambio], bool
\end_layout

\begin_layout LyX-Code
INHERITS Lista[Cambio]
\end_layout

\begin_layout LyX-Code
BASIC CONSTRUCTORS Crear
\end_layout

\begin_layout LyX-Code
DEFERRED
\end_layout

\begin_layout LyX-Code
TYPES Diferencial
\end_layout

\begin_layout LyX-Code
FUNCTIONS
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $Crear:\: Archivo\: x\: Archivo\: Subsecuencia\rightarrow Diferencial$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $Crear:\: Archivo\: x\: Archivo\: x\: bool\rightarrow Diferencial$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $getDiff:\: Diferencial\rightarrow Archivo$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $aplicarPatch:\: Diferencial\rightarrow Archivo$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code
END-CLASS
\end_layout

\begin_layout Section
Implementación de los TDAs
\end_layout

\begin_layout Subsection
Estructura de los proyectos
\end_layout

\begin_layout Standard
Los proyectos(diff y patch) fueron desarrollados con el entorno de desarrollo
 integrado Code::Blocks.
\end_layout

\begin_layout Standard
El código está contenido en los siguientes archivos:
\end_layout

\begin_layout Itemize
diffalgo.cbp: proyecto del diff.
\end_layout

\begin_layout Itemize
diff.cpp: programa principal del diff.
\end_layout

\begin_layout Itemize
Diferencial.h: encabezado de la clase Diferencial(*).
\end_layout

\begin_layout Itemize
Diferencial.cpp: implementación de la clase Diferencial(*).
\end_layout

\begin_layout Itemize
Cambio.h: encabezado de la clase Cambio y sus derivadas(*).
\end_layout

\begin_layout Itemize
Cambio.cpp: implementación de la clase Cambio y sus derivadas(*).
\end_layout

\begin_layout Itemize
Archivo.h: encabezado de la clase Archivo(*).
\end_layout

\begin_layout Itemize
Archivo.cpp: implementación de la clase Archivo(*).
\end_layout

\begin_layout Itemize
Lista.h: encabezado e implementación del template Lista e IteradorLista(*).
\end_layout

\begin_layout Itemize
Algoritmos.h: contiene la declaración de la función para calcular una subsecuenci
a común(el básico y el óptimo), y los tipos parInt y Subsecuencia.
\end_layout

\begin_layout Itemize
Algoritmos.cpp: implementación de las declaraciones en Algoritmos.h.
\end_layout

\begin_layout Itemize
patch.cbp: proyecto para el patch.
\end_layout

\begin_layout Itemize
patch.cpp: programa principal del patch.
\end_layout

\begin_layout Standard
Los archivos marcados con (*) son comúnes a ambos proyectos.
\end_layout

\begin_layout Standard
Como los diff de la primera y segunda entrega sólo difieren en la función
 para calcular una subsecuencia común, se decidió implementar ambos en el
 mismo proyecto y agregar una macro de compilación condicional en el archivo
 Algoritmos.h.
\end_layout

\begin_layout Subsection
Tipos Auxiliares
\end_layout

\begin_layout Subsubsection
Lista
\end_layout

\begin_layout Standard
Este tipo se implementó con un template para que pueda ser parametrizado.
\end_layout

\begin_layout Standard
Para que la inserción final de la lista tenga una complejidad temporal 
\begin_inset Formula $O\left(1\right)$
\end_inset

, se mantiene un puntero al último nodo.
 La inserción al principio también es constante.
 Las funciones principales son: 
\end_layout

\begin_layout LyX-Code
template <class T>
\end_layout

\begin_layout LyX-Code
void insertarFinal(const T & elem); 
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
template <class T>
\end_layout

\begin_layout LyX-Code
void insertarPrincipio(const T & elem);
\end_layout

\begin_layout Standard
El destructor recorre los nodos de la lista y los elimina uno por uno, su
 complejidad es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n la cantidad de nodos.
\end_layout

\begin_layout Subsubsection
IteradorLista
\end_layout

\begin_layout Standard
Este tipo también se implementó con un template.
 Recibe un puntero a una lista en el constructor.
 Puede acceder a los atributos privados de los objetos de tipo Lista ya
 que ha sido declarado como amigo(friend).
 Sus métodos principales son:
\end_layout

\begin_layout LyX-Code
template <class T>
\end_layout

\begin_layout LyX-Code
void IteradorLista<T>::sucesor()
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
template <class T>
\end_layout

\begin_layout LyX-Code
bool IteradorLista<T>::terminado()
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
template <class T>
\end_layout

\begin_layout LyX-Code
T IteradorLista<T>::elemActual()
\end_layout

\begin_layout Standard
La complejidad de estas tres funciones es 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
ParInt
\end_layout

\begin_layout Standard
Es una clase contenedora de un par de enteros.
 En el constructor se pasan los dos valores iniciales del par.
\end_layout

\begin_layout LyX-Code
class parInt {
\end_layout

\begin_deeper
\begin_layout LyX-Code
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code
int Primero() { return primero;}
\end_layout

\begin_layout LyX-Code
int Segundo() { return segundo;}
\end_layout

\begin_layout LyX-Code
parInt(int p, int s) : primero(p), segundo(s) { }
\end_layout

\end_deeper
\begin_layout LyX-Code
private:
\end_layout

\begin_deeper
\begin_layout LyX-Code
int primero, segundo;
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection
Subsecuencia
\end_layout

\begin_layout Standard
Se implementa simplemente parametrizando el template Lista con parInt.
\end_layout

\begin_layout LyX-Code
typedef Lista<parInt> Subsecuencia;
\end_layout

\begin_layout Subsubsection
Arreglo
\end_layout

\begin_layout Standard
Se utilizan los arreglos estándares de C/C++.
\end_layout

\begin_layout Subsection
Tipos Indispensables
\end_layout

\begin_layout Subsubsection
Línea
\end_layout

\begin_layout Standard
Se utiliza el tipo string de la STL, que permite hacer comparaciones y provee
 acceso aleatorio a sus caracteres.
\end_layout

\begin_layout Subsubsection
Archivo
\end_layout

\begin_layout Standard
En la implementación de este TDA se representaron las líneas mediante la
 composición de un arreglo de strings.
\end_layout

\begin_layout Standard
Para crear un Archivo se le pasa el nombre del archivo físico al constructor.
 La clase Archivo setea una variable booleana (errorAbrir) que permite al
 cliente, invocando al método isOpen, verificar que el archivo haya sido
 abierto correctamente.
 Para calcular el número de líneas de un archivo se implementó el método
 estático nroLineas que recibe un objeto de tipo ifstream y retorna un entero,
 con esta información se crea dinámicamente el arreglo de líneas (string
 * lineas) y se lo carga con el contenido del archivo.
 El constructor está sobrecargado para crear un archivo vacio a partir del
 número de líneas.
\end_layout

\begin_layout LyX-Code
Archivo::Archivo(const char nombre[])
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
Archivo::Archivo(int n)
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
bool Archivo::isOpen() const
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
string Archivo::getLinea(int n) const
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
void Archivo::setLinea(int n, const string & linea)
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
int Archivo::nroLineas(ifstream & arch)
\begin_inset VSpace defskip
\end_inset

int Archivo::getCantLineas() const
\end_layout

\begin_layout LyX-Code
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code
void Archivo::imprimir() const
\end_layout

\begin_layout Standard
La complejidad de isOpen, getLinea, setLinea, getCantLineas es de 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
 La complejidad para calcular el número de líneas y cargarlas, y para imprimir
 el archivo es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n cantidad de líneas.
\end_layout

\begin_layout Subsubsection
Cambio
\end_layout

\begin_layout Standard
Para favorecer el polimorfismo se implementó una clase abstracta, que representa
 a un cambio genérico.
 Se debieron agregar métodos para simplificar la implementación(principalmente
 del patch).
 
\end_layout

\begin_layout LyX-Code
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code
virtual string getDiff() = 0;
\end_layout

\begin_layout LyX-Code
virtual void aplicarPatch(Archivo&, int &, int &) = 0;
\end_layout

\begin_layout LyX-Code
virtual TipoCambio tipoCambio() = 0;
\end_layout

\begin_layout LyX-Code
virtual int getCantLineas() = 0;
\end_layout

\begin_layout LyX-Code
virtual int getIndiceOrigen() = 0;
\end_layout

\begin_layout LyX-Code
virtual bool editaAPartirDe(int) = 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
protected:
\end_layout

\begin_deeper
\begin_layout LyX-Code
Lista<string> lineas;
\end_layout

\end_deeper
\begin_layout Standard
El atributo protejido lineas, contiene las líneas que se deben agregar o
 eliminar.
 Se agregó reflexión en la clase Cambio a través de el método tipoCambio,
 que retorna un valor de tipo TipoCambio:
\end_layout

\begin_layout LyX-Code
enum TipoCambio {AGREGAR, ELIMINAR};
\end_layout

\begin_layout Standard
El método getDiff retorna la porción del diff del cambio, éste esta implementado
 especificamente en cada subclase de cambio, pero en general lo que hace
 es: recorre la lista de líneas y genera la parte del diff con el formato
 correspondiente.
 Entonces, su complejidad es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n la cantidad de líneas a editar.
\end_layout

\begin_layout Standard
El método getIndiceOrigen retorna el indice en el cual el cambio edita en
 el archivo origen(a partir de donde agrega si es CambioAgregar o a partir
 de donde elimina si es CambioEliminar).
 Este método es necesario para insertar los cambios en forma ordenada en
 el Diferencial cuando los cambios se extraen de un archivo diff; si bien
 los cambios estan bien ordenados cuando se interpreta el diff en el sentido
 en el que fue escrito(de origen a objetivo), el inconveniente surge cuando
 se debe interpretar el diff en forma inversa.
\end_layout

\begin_layout Standard
El método editaAPartirDe es utilizado en el algoritmo para aplicar el patch,
 se le pasa un número de línea del archivo al que se aplica el patch y este
 retorna afirmativamente si el cambio comienza a editar a partir de esa
 línea.
 Se detallará más sobre este método cuando se vea el algoritmo para aplicar
 un patch.
\end_layout

\begin_layout Standard
Por último, el método apicarPatch también está adaptado al algoritmo general
 de aplicación.
 Recibe el archivo en donde se está guardando el resultado de aplicación
 de cambios
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Se verá más adelante que la estrategía para aplicar un patch es crear un
 archivo nuevo, en vez de modificar uno existente.
\end_layout

\end_inset

, el índice la línea actual del archivo origen y el índice de la línea actual
 del archivo resultante(todos por referencia).
\end_layout

\begin_layout Subsubsection
CambioAgregar
\end_layout

\begin_layout Standard
Este TDA se implementó como una clase derivada de la clase Cambio.
 Contiene tres atributos privados que representan la línea del archivo origen
 a partir de la cual se agrega y las líneas de comienzo y fin del archivo
 destino.
 
\end_layout

\begin_layout Standard
Tiene dos constructores: uno que obtiene las líneas a agregar a partir del
 archivo objetivo, y otro que las obtiene a partir del archivo diff.
 La complejidad de ambos es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n las líneas a agregar, ya que ambos deben iterar sobre el archivo
 pasado e insertar cada una de las líneas en el atributo lineas.
\end_layout

\begin_layout Standard
El método aplicarPatch setea las líneas a agregar en el archivo resultante(a
 partir del índice pasado), actualizando también el indice de éste archivo.
 Su complejidad es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n las líneas a agregar.
\end_layout

\begin_layout Subsubsection
CambioEliminar
\end_layout

\begin_layout Standard
Esta clase es la simétrica a CambioAgregar para eliminación.
 Contiene tres atributos privados que representan las líneas de comienzo
 y fin del archivo origen y la línea del archivo destino.
\end_layout

\begin_layout Standard
Los constructores son análogos a los de CambioAgregar.
\end_layout

\begin_layout Standard
El método aplicarPatch simplemente actualiza el índice del archivo origen
 pasado por referencia(hace un salto de las líneas que deben eliminarse);
 por lo que su complejidad es de 
\begin_inset Formula $O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Diferencial
\end_layout

\begin_layout Standard
El tipo Diferencial se implementó usando la clase Lista parametrizada con
 punteros a objetos de tipo Cambio(para que sea polimórfica).
\end_layout

\begin_layout LyX-Code

\size footnotesize
public:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
Diferencial(Archivo & archorig, Archivo & archobj, const Subsecuencia &
 subsec);
\end_layout

\begin_layout LyX-Code

\size footnotesize
Diferencial(Archivo & Diff, Archivo & origen, bool inversa);
\end_layout

\begin_layout LyX-Code

\size footnotesize
void imprimirDiff();
\end_layout

\begin_layout LyX-Code

\size footnotesize
void aplicarPatch();
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
private:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
int calcularLineasObjetivo();
\end_layout

\begin_layout LyX-Code

\size footnotesize
void calcularCambiosDiff(Archivo &, bool);
\end_layout

\begin_layout LyX-Code

\size footnotesize
void crearCambiosSubsecuencia(const Subsecuencia &);
\end_layout

\begin_layout LyX-Code

\size footnotesize
Archivo *archorig, *archobj;
\end_layout

\end_deeper
\begin_layout Standard
Los métodos imprimirDiff y aplicarPatch muestran los resultados por  consola.
\end_layout

\begin_layout Standard
El método crearCambiosSubsecuencia es invocado en el primer constructor
 y calcularCambiosDiff en el segundo.
\end_layout

\begin_layout Standard
El método calcularLineasObjetivo es utilizado por aplicarPatch, devuelve
 la cantidad de líneas que tendrá el archivo origen después de que se le
 apliquen los cambios del objeto diferencial.
\end_layout

\begin_layout Section
Algoritmos utilizados y su complejidad
\end_layout

\begin_layout Subsection
Algoritmo simple para calcular una subsecuencia común
\end_layout

\begin_layout Standard
El algoritmo simple para calcular una subsecuencia, esta implementado en
 el archivo Algoritmos.cpp.
\end_layout

\begin_layout Standard
Básicamente, el algoritmo consiste en iterar sobre las líneas del archivo
 origen y por cada una de estas iterar en el archivo objetivo hasta encontrar
 una línea igual.
 Si se encuentra la línea correspondiente, las próximas iteraciones en el
 archivo objetivo comenzaran desde allí.
 Cuando se encuentran las líneas iguales, el par de índices que las identifica
 se inserta en la subsecuencia.
 El algoritmo termina cuando se itero sobre todas las líneas del archivo
 origen ó cuando el índice que indica desde donde se comienza en el archivo
 objetivo en la iteración es mayor que la cantidad de líneas de éste
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Este condición se da cuando la ultima línea del archivo destino está en
 la subsecuencia 
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Su pseudocódigo es el siguiente:
\end_layout

\begin_layout LyX-Code

\size footnotesize
k = 1 //índice que marca por donde se comienza en el archivo objetivo
\end_layout

\begin_layout LyX-Code

\size footnotesize
i = 1 //índice del archivo origen
\end_layout

\begin_layout LyX-Code

\size footnotesize
while (i <= longitud(ArchOri) && k <= longitud(ArchObj))
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
j = k
\end_layout

\begin_layout LyX-Code

\size footnotesize
while (j <= longitud(ArchObj) AND ArchOri[i] != ArchObj[j])
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
j++
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
if (j <= longitud(ArchObj)) //se encontraron líneas iguales
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
subsecuencia.insertar(i,j)
\end_layout

\begin_layout LyX-Code

\size footnotesize
k = j + 1 //se sigue después de esta linea en la próxima iteración
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
La complejidad temporal del algoritmo claramente depende de la longitud
 del archivo origen y objetivo, a las cuales llamaremos m y n respectivamente.
\end_layout

\begin_layout Standard
El peor de los casos se da cuando los archivos no tienen líneas en común,
 ya que en esta situación, por cada línea del archivo origen se itera por
 todas las del objetivo (el índice k permanece constante).
\end_layout

\begin_layout Standard
Entonces, sea 
\begin_inset Formula $T\left(m,n\right)$
\end_inset

 el tiempo que toma el algoritmo:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
T\left(m,n\right)\leq\sum_{k=1}^{m}\left[C_{0}+\sum_{j=1}^{n}C_{1}\right]+C_{2}\leq m.C_{0}+\sum_{i=1}^{m}\left[\sum_{j=1}^{n}C_{1}\right]+C_{2}\\
\leq m.C_{0}+\sum_{i=1}^{m}n.C_{1}+C_{2}\leq m.C_{0}+m.n.C_{1}+C_{2}\epsilon\: O\left(m.n\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Por lo tanto, la complejidad del algoritmo para calcular una subsecuencia
 común es de 
\begin_inset Formula $O\left(m.n\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
El mejor de los casos se da cuando los archivos son iguales debido a que
 el bucle while interno no hace ninguna iteración, en consecuencia, tiene
 complejidad de 
\begin_inset Formula $\Omega\left(m\right)$
\end_inset

 siendo m la longitud de ambos archivos.
\end_layout

\begin_layout Subsection
Algoritmo calcular la subsecuencia más larga
\end_layout

\begin_layout Standard
Para calcular la subsecuencia más larga entre dos archivos, se implementó
 el algoritmo dinámico dado en las clases de laboratorio.
 El algoritmo se encuentra implementado en el archivo Algoritmos.cpp.
\end_layout

\begin_layout Standard
Su pseudocódigo es:
\end_layout

\begin_layout LyX-Code

\size footnotesize
for i = 1 to m
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
LCS[i][0] = {0, nada}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
for i = 0 to n
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
LCS[0][i] = {0, nada}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
for i = 1 to m
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
for k = 1 to n
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
if (archorig[i] == archobj[k]) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
LCS[i][k] = {LCS[i-1][k-1]+1, diagonal}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
else if (LCS[i-1][k] >= LCS[i][k-1])
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
LCS[i][k] = {LCS[i-1][k], arriba}
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
LCS[i][k] = {LCS[i][k-1], izquierda}
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout LyX-Code

\size footnotesize
m--
\end_layout

\begin_layout LyX-Code

\size footnotesize
n--
\end_layout

\begin_layout LyX-Code

\size footnotesize
while m > 0 AND n > 0
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
if (LCS[m][n].flecha == diagonal)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
m--
\end_layout

\begin_layout LyX-Code

\size footnotesize
n--
\end_layout

\begin_layout LyX-Code

\size footnotesize
subsecuencia.insertarPrincipio(m,n)
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
else if (LCS[m][n].flecha = arriba)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
m--
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
else
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
n--
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
La complejidad temporal en el peor de los casos es de 
\begin_inset Formula $O\left(m.n\right)$
\end_inset

, siendo m y n la cantidad de líneas de los archivos origen y objetivo respectiv
amente.
 Esto se ve claramente analizando los dos bucles for anidados, y considerando
 que la complejidad del bucle while final es sólo 
\begin_inset Formula $O\left(m+n\right)$
\end_inset

.
 Considerando el mejor de los casos, vemos que la complejidad del algoritmo
 no cambia(sólo cambia la parte del bucle while pero los bucles for son
 los dominantes) por lo que obtenemos una complejidad de 
\begin_inset Formula $\Omega\left(m.n\right)$
\end_inset

.
 Como ambas complejidades calculadas son iguales, deducimos que la complejidad
 del algoritmo es 
\begin_inset Formula $\Theta\left(m.n\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Comparación entre el algoritmo básico y el óptimo
\end_layout

\begin_layout Standard
Las ventajas del algoritmo básico son:
\end_layout

\begin_layout Itemize
Es más facil de entender y más compacto.
\end_layout

\begin_layout Itemize
La complejidad temporal en el mejor de los casos es menor que la del óptimo.
\end_layout

\begin_layout Itemize
No requiere espacio adicional.
\end_layout

\begin_layout Standard
Y sus desventajas son:
\end_layout

\begin_layout Itemize
En algunos casos calcula subsecuencias de tamaño mucho menor en comparación
 con la subsecuencia más larga.
\end_layout

\begin_layout Standard
Las ventajas del algoritmo óptimo son:
\end_layout

\begin_layout Itemize
Calcula la subsecuencia más larga en todos los casos.
\end_layout

\begin_layout Itemize
Su complejidad temporal en el peor de los casos es igual a la del algoritmo
 básico
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Aunque hay que tener en cuenta que el peor de los casos en el algoritmo
 básico ocurre con poca frecuencia, mientras que en el óptimo es el caso
 general.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Y sus desventajas:
\end_layout

\begin_layout Itemize
Su complejidad espacial es mayor: 
\begin_inset Formula $O\left(m.n\right)$
\end_inset

, siendo m y n el tamaño de los archivos.
\end_layout

\begin_layout Itemize
En general, la complejidad temporal es mayor con respecto al algoritmo básico.
\end_layout

\begin_layout Standard
En conclusión podemos decir que el algoritmo básico es más rápido y requiere
 menos espacio.
 Pero, quizás la ventaja más importante, que casi podría considerarse una
 cuestión de correctitud, la tiene el algoritmo óptimo, que calcula la subsecuen
cia más larga en todos los casos.
\end_layout

\begin_layout Subsection
Algoritmo para crear la lista de cambios
\end_layout

\begin_layout Standard
A partir de una subsecuencia común de líneas, se debe generar la lista de
 cambios que permita transformar un archivo a otro por medio de ediciones
 (adiciones y eliminaciones de líneas).
 Este algoritmo está implementado en el método calcularCambiosSubsecuencia(priva
do) de la clase Diferencial.
\end_layout

\begin_layout Standard
El algoritmo consiste en iterar sobre la subsecuencia y encontrar los saltos
 que se producen en los índices de cada par con respecto a los indices del
 par anterior.
 Cuando se registra un salto en uno o ambos elementos del par actual, significa
 que debe crearse un cambio; CambioEliminar cuando el salto se produce en
 el índice del archivo origen y CambioAgregar cuando el salto es en el índice
 del archivo objetivo.
 Esta iteración puede implementarse con un bucle, pero es necesario considerar
 fuera de éste las ediciones al principio y al final.
 
\end_layout

\begin_layout Standard
Para que los cambios queden ordenados en orden de aplicación si hay dos
 saltos en un par de la subsecuencia, se crea el CambioAgregar antes que
 el CambioEliminar.
\end_layout

\begin_layout Standard
su pseudocódigo es:
\end_layout

\begin_layout LyX-Code

\size footnotesize
//índices de los elementos anteriores en la subsecuencia
\end_layout

\begin_layout LyX-Code

\size footnotesize
i = 1
\end_layout

\begin_layout LyX-Code

\size footnotesize
k = 1
\end_layout

\begin_layout LyX-Code

\size footnotesize
Iterador it(subsecuencia)
\end_layout

\begin_layout LyX-Code

\size footnotesize
if (!it.terminado()) //si hay elementos en la subsecuencia
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
if (it.elemActual.segundo > k) //salto al principio?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioAgregar(...))
\size scriptsize
//se crea el cambio que agrega al principio
\end_layout

\begin_layout LyX-Code

\size footnotesize
k = it.elemActual.segundo
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
if (it.elemActual.primero > i) //se produjo un salto al principio?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioEliminar(...))//
\size scriptsize
se crea el cambio que elimina al principio
\end_layout

\begin_layout LyX-Code

\size footnotesize
i = it.elemActual.primero
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
it.sucesor() //se actualiza el iterador para el comienzo del bucle
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
else // subsecuencia vacía
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
i = k = 0 
\size scriptsize
//en este caso se deben agregar todas las de objetivo
\end_layout

\begin_layout LyX-Code

\size scriptsize
            //y eliminar todas las de origen
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
while (!it.terminado())
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
if (it.elemActual.segundo > k + 1) // salto?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioAgregar(...))
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
if (it.elemActual.primero > i + 1) // se produjo un salto?
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioEliminar(...)) 
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
i = it.elemActual.primero
\end_layout

\begin_layout LyX-Code

\size footnotesize
k = it.elemActual.segundo
\end_layout

\begin_layout LyX-Code

\size footnotesize
it.sucesor()
\end_layout

\end_deeper
\begin_layout LyX-Code

\size scriptsize
// ahora deben chequearse los índices para ver si hay que agregar o eliminar
 al final
\end_layout

\begin_layout LyX-Code

\size footnotesize
if (longitud(archobj) > k)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioAgregar(...))
\end_layout

\end_deeper
\begin_layout LyX-Code

\size footnotesize
if (longitud(archorig) > i)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\size footnotesize
cambios.insertar(cambioEliminar(...))
\end_layout

\end_deeper
\begin_layout Standard
Podemos calcular la complejidad temporal de éste algoritmo a partir de la
 longitud de los archivos y considerando la complejidad para crear un cambio,
 que es de 
\begin_inset Formula $O\left(n\right)$
\end_inset

, siendo n el número de líneas a editar.
\end_layout

\begin_layout Standard
Sea m y n la cantidad de líneas de los archivos origen y objetivo respectivament
e, el peor de los casos ocurre cuando los archivos no tienen líneas en común,
 y en consecuencia, la subsecuencia es vacia.
 En este caso, deben crearse dos cambios: uno para eliminar todas las líneas
 del archivo origen, y otro que agregue las líneas del archivo objetivo.
 Entonces la complejidad del algoritmo es de 
\begin_inset Formula $O(m+n)$
\end_inset

.
\end_layout

\end_body
\end_document
